/**
*
* Build one or many packages by Gerrit refspec and deploy to different OpenStack releases.
*
* Expected parameters:
*    UPLOAD_APTLY                 This boolean sets whether need to upload to and publish to Aptly packages.
*    BUILD_PACKAGE                This boolean sets whether need to build packages before deployment.
*    SOURCE_CREDENTIALS           Credentials to Git access
*    APTLY_REPO                   Aptly repo name to use as a extra repo deploy name. Leave it blank for autogenerated.
*    APTLY_API_URL                Aptly API interface URL
*    APTLY_REPO_URL               Aptly repo URL
*    OPENSTACK_RELEASES           List of openstack release to deploy env. Comma as a delimiter.
*    SOURCES                      List of patchsets to be built and delpoy.
*                                 Format: <Git URL1> <REFSPEC1>\n<Git URL2> <REFSPEC2>
*    STACK_RECLASS_ADDRESS        Git URL to reclass model to use for deployment.
*    PKG_BUILD_JOB_NAME           Jenkins job name to build pakages. Default: oscore-ci-build-formula-change
*    GERRIT_*                     Gerrit trigger plugin variables.
*    TEST_TEMPEST_PATTERN         Tempest tests pattern
*    SOURCE_REPO_NAME             Name of the repo where packages are stored. For example: ubuntu-xenial-salt
*    OPENSTACK_COMPONENTS_LIST    OpenStack related components list. For example: 'nova,cinder,glance,keystone,horizon,neutron,designate,heat,ironic,barbican'
*    COMPONENTS                   Components for repo. For example: salt
*
*    There are 2 options to run the pipeline:
*    1. Manually.
*       In this case need to define SOURCES parameter. See above.
*    2. Automatically by Gerrit trigger.
*       In this case Gerrit trigger adds GERRIT_* paramters to the build and the pipeline will use it.
*       SOURCES parameter should be empty.
*
*/

def common = new com.mirantis.mk.Common()
def aptly = new com.mirantis.mk.Aptly()
def http = new com.mirantis.mk.Http()

/**
 * Unpublish and delete Aptly repo by REST API
 *
 * @param aptlyServer Aptly connection object
 * @param aptlyPrefix Aptly prefix where need to delete a repo
 * @param aptlyRepo  Aptly repo name
 */
def aptlyCleanup(aptlyServer, aptlyPrefix, aptlyRepo){
    def common = new com.mirantis.mk.Common()
    def aptly = new com.mirantis.mk.Aptly()

    try {
        aptly.unpublishByAPI(aptlyServer, aptlyPrefix, aptlyRepo)
    } catch (Exception e) {
        common.warningMsg('Exception during Aptly unpublish. Message: ' + e.toString())
    }
    try {
        aptly.deleteRepoByAPI(aptlyServer, aptlyRepo)
    } catch (Exception e) {
        common.warningMsg('Exception during Aptly repo delete. Message: ' + e.toString())
    }
}

/**
 * Unpublish and delete snapshot by REST API
 *
 * @param aptlyServer Aptly connection object
 * @param aptlyPrefix Aptly prefix where need to delete a repo
 * @param aptlyRepo  Aptly repo name
 */
def aptlyCleanupSnapshot(aptlyServer, aptlyPrefix, aptlyRepo){
    def common = new com.mirantis.mk.Common()
    def aptly = new com.mirantis.mk.Aptly()
    def http = new com.mirantis.mk.Http()

    try {
        aptly.unpublishByAPI(aptlyServer, aptlyPrefix, aptlyRepo)
    } catch (Exception e) {
        common.warningMsg('Exception during Aptly unpublish. Message: ' + e.toString())
    }
    try {
        http.restDelete(aptlyServer, "api/snapshots/${aptlyRepo}")
    } catch (Exception e) {
        common.warningMsg('Exception during snapshot deletion. Message: ' + e.toString())
    }
}


def setGerritBuildString(buildObj){
    return "* ${buildObj.getProjectName()} ${buildObj.absoluteUrl} : ${buildObj.result} ${buildObj.durationString}"
}

def messages = ["${env.BUILD_URL}"]

def buildPackage = true
if (common.validInputParam('BUILD_PACKAGE')) {
    buildPackage = BUILD_PACKAGE.toBoolean()
}

def aptlyRepo = ''
if (common.validInputParam('APTLY_REPO')) {
    aptlyRepo = APTLY_REPO
}

def uploadAptly = true
if (common.validInputParam('UPLOAD_APTLY')) {
    uploadAptly = UPLOAD_APTLY.toBoolean()
}

def pkgBuildJobName = 'oscore-ci-build-formula-change'
if (common.validInputParam('PKG_BUILD_JOB_NAME')) {
    pkgBuildJobName = PKG_BUILD_JOB_NAME
}

def stackDelete = true
if (common.validInputParam('STACK_DELETE')) {
    stackDelete = STACK_DELETE.toBoolean()
}

def sources
if (common.validInputParam('SOURCES')) {
    sources = SOURCES
} else if (common.validInputParam('GERRIT_REFSPEC')) {
        sources = "${GERRIT_SCHEME}://${GERRIT_NAME}@${GERRIT_HOST}:${GERRIT_PORT}/${GERRIT_PROJECT} ${GERRIT_REFSPEC}"
} else {
    common.errorMsg('SOURCES or GERRIT_* parameters are empty.')
    currentBuild.result = 'FAILURE'
}

def aptlyPrefix = 'oscc-dev'
if (common.validInputParam('APTLY_PREFIX')) {
    aptlyPrefix = APTLY_PREFIX
}

def systestJobPrefix = 'oscore-formula-systest-virtual_mcp11_aio-'
if (common.validInputParam('SYSTEST_JOB_PREFIX')) {
    systestJobPrefix = SYSTEST_JOB_PREFIX
}

def test_tempest_pattern = ''
if (common.validInputParam('TEST_TEMPEST_PATTERN')) {
    test_tempest_pattern = TEST_TEMPEST_PATTERN
}

node('python') {
    def components = 'salt'
    if (common.validInputParam('COMPONENTS')) {
        components = COMPONENTS
    }

    def aptlyServer = ['url': APTLY_API_URL]
    wrap([$class: 'BuildUser']) {
        if (env.BUILD_USER_ID) {
          buidDescr = "${env.BUILD_USER_ID}-${JOB_NAME}-${BUILD_NUMBER}"
        } else {
          buidDescr = "jenkins-${JOB_NAME}-${BUILD_NUMBER}"
        }
    }
    currentBuild.description = buidDescr
    if (aptlyRepo == ''){
        aptlyRepo = buidDescr
    }

    // Name of the nightly repo which will be published for testing
    def aptlyRepo_nightly = "${aptlyRepo}-nightly"

    dir('build-area'){
        deleteDir()
    }
    if (buildPackage) {
        stage('Build packages') {
            for (source in sources.tokenize('\n')) {
                sourceArr = source.tokenize(' ')
                deployBuild = build(job: pkgBuildJobName, propagate: false, parameters: [
                    [$class: 'StringParameterValue', name: 'SOURCE_URL', value: "${sourceArr[0]}"],
                    [$class: 'StringParameterValue', name: 'SOURCE_REFSPEC', value: "${sourceArr[1]}"],
                ])
                /*
                   Here and further insert elements to the beginning of messages in order to get next gerrit message:
                   * ChildProjectName1 absoluteUrl : result durationString
                   * ChildProjectName2 absoluteUrl : result durationString
                   * ChildProjectName3 absoluteUrl : result durationString
                   * ChildProjectName1 absoluteUrl : result durationString
                   * ParentBuildUrl:result
                */
                messages.add(0, setGerritBuildString(deployBuild))
                setGerritReview customUrl: messages.join('\n')
                if (deployBuild.result == 'SUCCESS'){
                    common.infoMsg("${source} has been build successfully ${deployBuild}")
                } else {
                    error("Cannot build ${source}, please check ${deployBuild.absoluteUrl}")
                }

                step ([$class: 'CopyArtifact',
                    projectName: "${deployBuild.getProjectName()}",
                    filter: 'build-area/*.deb',
                    selector: [$class: 'SpecificBuildSelector', buildNumber: "${deployBuild.getId()}"],
                    ])
                archiveArtifacts artifacts: 'build-area/*.deb'
            }
        }
    }

    try {
        dir('build-area'){
            lock('aptly-api') {
                if (uploadAptly && buildPackage) {
                    stage('upload to Aptly') {
                        def buildSteps = [:]
                        def data = [:]
                        data['Name'] = "${aptlyRepo}"
                        http.restPost(aptlyServer, '/api/repos', data)
                        def debFiles = sh script: 'ls *.deb', returnStdout: true
                        for (file in debFiles.tokenize()) {
                        buildSteps[file.split('_')[0]] = aptly.uploadPackageStep(
                            file,
                            APTLY_API_URL,
                            aptlyRepo,
                            true
                            )
                        }
                        parallel buildSteps
                    }
                }
                stage('publish to Aptly') {
                    def source = [:]
                    source['Name'] = aptlyRepo
                    def data = [:]
                    data['SourceKind'] = 'local'
                    data['Sources'] = [source]
                    data['Architectures'] = ['amd64']
                    data['Distribution'] = aptlyRepo
                    http.restPost(aptlyServer, "/api/publish/${aptlyPrefix}", data)
                }

                stage('Creating snapshot from nightly repo'){
                    def nightlySnapshot = aptly.getSnapshotByAPI(aptlyServer, 'nightly', 'xenial', components)
                    def snapshotpkglist = aptly.snapshotPackagesByAPI(aptlyServer, nightlySnapshot, OPENSTACK_COMPONENTS_LIST)

                    aptly.snapshotCreateByAPI(aptlyServer, SOURCE_REPO_NAME, aptlyRepo_nightly, null, snapshotpkglist)
                    common.successMsg("Snapshot ${aptlyRepo_nightly} has been created for packages: ${snapshotpkglist}")
                }

                stage('Publishing the snapshot'){
                    common.infoMsg("Publishing ${aptlyRepo_nightly} for prefix ${aptlyPrefix} is started.")
                    aptly.snapshotPublishByAPI(aptlyServer, aptlyRepo_nightly, aptlyRepo_nightly, components, aptlyPrefix)
                    common.successMsg("Snapshot ${aptlyRepo_nightly} has been published for prefix ${aptlyPrefix}")
                }
            }
        }

        if (OPENSTACK_RELEASES) {
            def deploy_release = [:]
            def testBuilds = [:]
            URI aptlyUri = new URI(APTLY_REPO_URL)
            def aptlyHost = aptlyUri.getHost()
            def extraRepo = "deb [ arch=amd64 trusted=yes ] ${APTLY_REPO_URL}/${aptlyPrefix} ${aptlyRepo} main,1300,origin ${aptlyHost}; deb [ arch=amd64 trusted=yes ] ${APTLY_REPO_URL}/${aptlyPrefix} ${aptlyRepo_nightly} main,1200,release n=${aptlyRepo_nightly}"
            stage('Deploying environment and testing'){
                for (openstack_release in OPENSTACK_RELEASES.tokenize(',')) {
                    def release = openstack_release
                    deploy_release["OpenStack ${release} deployment"] = {
                        node('oscore-testing') {
                            testBuilds["${release}"] = build job: "${systestJobPrefix}${release}", propagate: false, parameters: [
                                [$class: 'StringParameterValue', name: 'STACK_RECLASS_ADDRESS', value: "${STACK_RECLASS_ADDRESS}"],
                                [$class: 'StringParameterValue', name: 'STACK_RECLASS_BRANCH', value: "stable/${release}"],
                                [$class: 'TextParameterValue', name: 'BOOTSTRAP_EXTRA_REPO_PARAMS', value: extraRepo],
                                [$class: 'BooleanParameterValue', name: 'STACK_DELETE', value: stackDelete],
                                [$class: 'StringParameterValue', name: 'TEST_TEMPEST_PATTERN', value: test_tempest_pattern],
                            ]
                        }
                    }
                }
                parallel deploy_release
            }
            def notToPromote
            stage('Managing deployment results') {
                for (k in testBuilds.keySet()) {
                    if (testBuilds[k].result != 'SUCCESS') {
                        notToPromote = true
                    }
                    println(k + ': ' + testBuilds[k].result)
                    messages.add(0, setGerritBuildString(testBuilds[k]))
                }
            }
            if (notToPromote) {
                currentBuild.result = 'FAILURE'
            }
        }
    } catch (Exception e) {
        currentBuild.result = 'FAILURE'
        throw e
    } finally {
        setGerritReview customUrl: messages.join('\n')
        stage('Cleanup Aptly') {
            lock('aptly-api') {
                aptlyCleanup(aptlyServer, aptlyPrefix, aptlyRepo)
                aptlyCleanupSnapshot(aptlyServer, aptlyPrefix, aptlyRepo_nightly)
            }
        }
    }
// end of node
}


